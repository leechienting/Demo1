# Array、Set、Dictionary 使用場景條列指南

## 一、Array（陣列）

### ✅ 適合使用的場景

**1\. 需要保持順序的資料**

- 聊天訊息列表：訊息必須按時間順序顯示

- 音樂播放清單：歌曲播放順序很重要

- 歷史記錄：瀏覽順序、操作順序需要被記錄

- 步驟流程：註冊流程、教學步驟等有先後順序的內容

- 時間軸資料：貼文動態、交易記錄等

**2\. 需要索引存取的資料**

- UITableView/UICollectionView 資料源：需要用 indexPath.row 快速存取

- 分頁資料：可以用範圍快速取得某一頁的資料

- 滑動輪播：需要知道當前在第幾張

- 排行榜：第一名、第二名等位置有意義

- 格子遊戲：棋盤、拼圖等需要二維陣列的場景

**3\. 需要排序的資料**

- 成績排名：需要從高到低或從低到高排序

- 商品列表：可依價格、評分、熱門度等多種方式排序

- 任務清單：可依優先級、截止日期排序

- 搜尋結果：通常需要依相關性排序

- 時間範圍內的資料：可依日期時間排序

**4\. 允許重複元素的場景**

- 購物車商品數量：同一商品可以有多個

- 用戶行為記錄：可能重複訪問同一頁面、重複點擊

- 投票記錄：同一選項可能被多次選擇

- 遊戲分數歷史：分數可能重複

- 標籤雲：同一標籤在不同文章中重複出現

**5\. 需要大量讀取、少量修改的場景**

- 設定選項列表：讀取頻繁但很少改變

- 國家/城市清單：相對固定的列表

- 產品規格：展示用的固定資料

- 導覽選單項目：通常是固定的

### ❌ 不適合使用的場景

**1\. 頻繁的查找操作**

- 檢查會員身份：每次都要遍歷整個陣列，O(n) 效能差

- 檢查是否已加入最愛：contains 操作在大量資料時很慢

- 權限驗證：需要快速判斷用戶是否有某權限

- 黑名單檢查：頻繁檢查某 ID 是否在名單中

- 這些場景應該改用 Set，查找效能是 O(1)

**2\. 需要保證唯一性**

- 已讀訊息 ID：不應該重複記錄

- 用戶標籤：同一標籤不該出現兩次

- 下載佇列：同一檔案不該重複下載

- 選中的項目：複選框的選擇結果應該去重

- 用 Array 需要每次手動檢查重複，效能差且容易出錯

**3\. 頻繁的中間插入/刪除操作**

- 優先佇列：需要頻繁在中間插入任務

- 排序維護：插入新元素後要保持排序

- 任務排程：需要頻繁調整任務順序

- 這些操作在 Array 中是 O(n)，因為要移動大量元素

- 應該考慮其他資料結構如 Heap、LinkedList

**4\. 需要快速的成員檢查**

- 去重操作：如果經常要檢查某元素是否已存在

- 集合運算：需要做交集、聯集、差集

- 關聯性查找：需要找兩個集合的共同部分

- 這些場景用 Set 會快很多

---

## 二、Set（集合）

### ✅ 適合使用的場景

**1\. 需要快速查找成員資格**

- 黑名單/白名單：快速檢查某 ID 是否在名單中

- 權限檢查：快速判斷用戶是否有某個權限

- 功能開關：檢查某功能是否啟用

- 已讀狀態：檢查訊息是否已讀

- 會員驗證：檢查是否為有效會員

- 所有檢查都是 O(1)，比 Array 的 O(n) 快很多

**2\. 需要自動去重**

- 文章標籤：一篇文章的標籤不該重複

- 用戶技能：技能列表應該唯一

- 訂閱列表：不該重複訂閱同一頻道

- 收藏夾：同一項目不該被收藏兩次

- 關注列表：不該重複關注同一人

- 不需要手動檢查重複，insert 時自動處理

**3\. 集合運算需求**

- 共同好友：兩個用戶的好友交集

- 推薦功能：朋友的朋友減去已是好友的

- 權限管理：合併多個角色的權限

- 資料比對：找出兩組資料的差異

- 去重合併：合併多個來源的資料

- Set 提供 intersection、union、subtracting 等方法

**4\. 不在乎順序的唯一元素集合**

- 已觀看的影片 ID：只關心看過沒，不在乎順序

- 點讚的貼文 ID：不需要知道點讚順序

- 已完成的任務 ID：完成順序不重要

- 下載中的檔案 URL：不在乎下載順序

- 啟用的功能名稱：功能順序無意義

**5\. 需要高效插入和刪除**

- 線上用戶列表：用戶頻繁上線下線

- 購物車商品 ID 集合（不考慮數量）：加入移除很頻繁

- 搜尋歷史去重：頻繁加入新的搜尋詞

- 快取鍵管理：頻繁加入和移除快取項目

- 插入和刪除都是 O(1)

### ❌ 不適合使用的場景

**1\. 需要保持插入順序**

- 操作歷史：需要知道哪個操作先發生

- 聊天訊息：必須按時間順序顯示

- 播放清單：歌曲順序決定播放次序

- 瀏覽記錄：要知道瀏覽順序

- Set 的遍歷順序是任意的，無法保證順序

**2\. 需要索引存取**

- 第一筆資料、最後一筆資料：Set 沒有「第幾個」的概念

- 分頁顯示：無法取得「第 10-20 筆」資料

- 輪播功能：無法知道「下一個」是什麼

- Set 沒有下標，無法用 set\[0\] 這樣的方式存取

**3\. 需要計數或允許重複**

- 購物車數量：同一商品可能有多個

- 單字出現次數：需要統計每個單字出現幾次

- 投票結果：需要知道每個選項有多少票

- 訪問次數統計：需要累計訪問次數

- Set 的每個元素只能出現一次，應該用 Dictionary 計數

**4\. 元素無法實作 Hashable**

- 包含閉包的結構：閉包無法 hash

- 包含可變物件的結構：不穩定的 hash 值

- 需要自訂相等邏輯但無法實作的型別

- 必須讓型別遵循 Hashable 協定才能放入 Set

**5\. 需要排序顯示**

- 成績高低排名：需要按分數排序

- 價格由低到高：需要按價格排序

- 時間先後排序：需要按時間排序

- Set 本身不保證順序，要排序需要轉成 Array

---

## 三、Dictionary（字典）

### ✅ 適合使用的場景

**1\. 鍵值對應關係**

- 用戶資料快取：用 userID 快速找到 User 物件

- 設定管理：用設定名稱取得設定值

- 翻譯對照表：用原文查詢譯文

- 錯誤碼對應：用錯誤代碼查詢錯誤訊息

- API 回應解析：JSON 的 key-value 結構

- 查找效能是 O(1)，比遍歷 Array 快很多

**2\. 計數統計**

- 單字出現次數：記錄每個單字出現了幾次

- 投票統計：記錄每個選項的票數

- 訪問次數：記錄每個頁面被訪問幾次

- 錯誤次數：記錄每種錯誤發生幾次

- 庫存數量：記錄每個商品的庫存

- 用 default 參數可以方便地累加計數

**3\. 分組歸類**

- 按類別分組商品：用類別名稱分組產品列表

- 按日期分組交易：用日期分組當天的交易

- 按作者分組文章：用作者 ID 分組文章

- 按狀態分組任務：用狀態（待辦/進行中/完成）分組

- 按標籤分組內容：用標籤分組相關內容

**4\. 建立索引加速查找**

- 通訊錄索引：用電話號碼或 email 快速找人

- 產品索引：用 SKU、ID、條碼等多種方式查找

- 訂單索引：用訂單號快速找到訂單詳情

- 有了索引後，查找從 O(n) 變成 O(1)

- 適合資料量大且查找頻繁的場景

**5\. 配置和映射**

- HTTP 狀態碼對應訊息：200→"OK", 404→"Not Found"

- 鍵盤快捷鍵映射：Cmd+S→儲存, Cmd+C→複製

- 路由表：URL path 對應到 handler

- 事件處理器映射：事件名稱對應到處理函式

- 枚舉的顯示文字：用 enum 查找對應的顯示文字

**6\. 快取和備忘錄**

- 圖片快取：用 URL 快速找到已下載的圖片

- 計算結果快取：避免重複計算費氏數列等

- 網路請求快取：用請求參數快取回應結果

- 資料庫查詢快取：用查詢條件快取結果

- 大幅提升效能，避免重複工作

### ❌ 不適合使用的場景

**1\. 需要保持插入順序**

- 表單欄位：需要按特定順序顯示

- 設定項目列表：需要按類別順序排列

- 步驟流程：註冊步驟需要按順序

- Dictionary 的遍歷順序不可預測

- 需要順序時應該用 Array of tuples 或配合 Array 記錄順序

**2\. 只需要判斷存在性（不需要 value）**

- 已訪問的頁面：只需知道是否訪問過

- 已完成的任務：只需知道是否完成

- 黑名單：只需知道是否在名單中

- 如果 value 只是 true/false，應該改用 Set

- Dictionary 會浪費記憶體空間

**3\. 鍵無法實作 Hashable**

- 自訂結構沒有遵循 Hashable

- 包含不可 hash 的屬性

- 需要自訂相等判斷但無法實作 hash

- 必須讓 key 型別遵循 Hashable 協定

**4\. 需要按特定順序遍歷**

- 按字母順序顯示設定項目

- 按時間順序顯示資料

- 按優先級顯示任務

- Dictionary 本身無序，需要先轉成 Array 再排序

- 如果經常需要排序，可能不適合用 Dictionary

**5\. 資料關聯性簡單時**

- 如果只是簡單的一對一對應且數量少

- 用 switch 或 if-else 可能更清楚

- 不要為了用 Dictionary 而過度設計

- 簡單的場景用簡單的方法

---

## 四、組合使用的常見模式

**模式 1：Dictionary + Array（保持順序的映射）**

- Dictionary 用來快速查找：productID → Product

- Array 用來記錄順序：\[productID1, productID2, ...\]

- 範例：購物車（要快速查找商品，又要保持加入順序）

**模式 2：Set + Array（去重後的有序列表）**

- 先用 Set 去重

- 再轉成 Array 並排序

- 範例：搜尋建議（要去重，又要按熱門度排序）

**模式 3：Dictionary + Set（多對多關係）**

- Dictionary 的 value 是 Set

- 範例：用戶與權限（一個用戶有多個權限，權限不重複）

- 範例：文章與標籤（一篇文章有多個標籤，標籤不重複）

**模式 4：Dictionary 的 Dictionary（二維索引）**

- 第一層 key：類別

- 第二層 key：ID

- 範例：多條件快速查找（先按類別再按 ID）

**模式 5：Array of Dictionary（列表資料）**

- 每個 Dictionary 代表一筆記錄

- 範例：JSON 格式的列表資料

- 範例：表格的每一列資料

---

## 五、選擇決策樹

**步驟 1：是否需要 Key-Value 配對？**

- 是 → Dictionary

- 否 → 繼續

**步驟 2：是否需要保證唯一性？**

- 是 → Set

- 否 → 繼續

**步驟 3：是否需要頻繁查找成員？**

- 是 → Set（即使後續要轉 Array）

- 否 → 繼續

**步驟 4：是否需要保持順序或索引存取？**

- 是 → Array

- 否 → 重新檢視需求

**步驟 5：是否需要計數統計？**

- 是 → Dictionary（key 是項目，value 是次數）

**步驟 6：是否需要分組？**

- 是 → Dictionary（key 是群組，value 是 Array）

---

## 六、效能比較總結

**查找操作（contains/查詢）**

- Array：O(n) - 要遍歷整個陣列

- Set：O(1) - hash 查找

- Dictionary：O(1) - hash 查找

- **結論**：需要快速查找用 Set 或 Dictionary

**插入操作**

- Array 尾端：O(1) - append 很快

- Array 中間：O(n) - 需要移動元素

- Set：O(1) - 平均情況

- Dictionary：O(1) - 平均情況

- **結論**：頻繁插入刪除用 Set 或 Dictionary

**保持順序**

- Array：✅ 保持插入順序

- Set：❌ 無序

- Dictionary：❌ 無序

- **結論**：需要順序只能用 Array

**去重能力**

- Array：❌ 需要手動檢查

- Set：✅ 自動去重

- Dictionary：✅ key 自動唯一

- **結論**：需要唯一性用 Set 或 Dictionary

**記憶體使用**

- Array：最緊湊（連續記憶體）

- Set：需要額外空間存 hash

- Dictionary：需要最多空間（key + value + hash）

- **結論**：記憶體敏感優先用 Array