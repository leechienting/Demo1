# Swift 中的逃逸閉包與非逃逸閉包

[Swift 中的逃逸閉包與非逃逸閉包：每位 iOS 開發者都該深入瞭解的關鍵解析 ! 作者：Gaurav Tak ! 咖啡☕與程式碼💚 ! 2025 年 10 月 ! Medium --- .pdf](../Card%20Library/Swift%20中的逃逸閉包與非逃逸閉包：每位%20iOS%20開發者都該深入瞭解的關鍵解析%20!%20作者：Gaurav%20Tak%20!%20咖啡☕與程式碼💚%20!%202025%20年%2010%20月%20!%20Medium%20---%20.pdf)

![Pasted 2025-11-10-11-34-49.png](./Swift%20中的逃逸閉包與非逃逸閉包-assets/Pasted%202025-11-10-11-34-49.png)

### 核心論點

本文深入探討了 Swift 中逃逸（Escaping）與非逃逸（Non-Escaping）閉包的核心差異。文章強調，理解兩者的生命週期與記憶體管理機制，對於編寫安全且高效的非同步程式碼至關重要，特別是在處理網路請求或延時操作等常見 iOS 開發場景時。

### 內容架構

- **什麼是閉包？** 閉包是 Swift 中強大的功能，可以像變數一樣被傳遞和使用，並捕獲其周圍環境的常數和變數。

- **非逃逸閉包** 這是 Swift 閉包的預設類型，其生命週期不會超過函式的執行範圍，因此在函式返回後就會被釋放，有助於編譯器進行效能優化。

- **逃逸閉包** 逃逸閉包的生命週期會超過函式的執行範圍，通常用於非同步操作，例如網路請求的回調函式，它會在函式執行完畢後某個時間點才被調用。

- **為什麼 Swift 要強制使用 `@escaping`？** 明確標記 `@escaping` 是為了提醒開發者注意潛在的記憶體管理問題，因為逃逸閉包可能導致循環引用，需要謹慎處理 `self` 的捕獲。

- **`self` 的捕獲與循環引用** 當在逃逸閉包中使用 `self` 時，若未妥善處理，可能產生循環引用，導致記憶體洩漏；文章說明了如何使用 `[weak self]` 或 `[unowned self]` 來避免此問題。

   - [弱引用 (Weak Reference).md](./弱引用%20\(Weak%20Reference\).md)、[無主引用 (Unowned Reference).md](./無主引用%20\(Unowned%20Reference\).md)

- **重點總結** 文章最後透過比較表格和範例，總結了兩種閉包在執行時機、生命週期、記憶體管理和使用場景上的關鍵區別，並提供了實用的建議。

### 關鍵觀點

- **生命週期是核心區別** 非逃逸閉包在函式執行結束後即被銷毀，而逃逸閉包則會被儲存起來，直到未來的某個時間點才執行。例如，`UIView.animate` 的 `animations` 閉包是非逃逸的，而 `completion` 閉包則是逃逸的，因為它在動畫結束後才被調用。

- **`@escaping` 標記的必要性** Swift 強制要求為逃逸閉包加上 `@escaping` 標記，以提醒開發者注意記憶體管理。當閉包被賦值給外部變數，或是在非同步操作（如 `DispatchQueue.main.asyncAfter`）中延遲執行時，就必須使用此標記。

- **記憶體管理與循環引用** 在逃逸閉包中直接使用 `self` 會增加其引用計數，可能造成循環引用。為避免記憶體洩漏，應使用 `[weak self]` 或 `[unowned self]` 來打破強引用循環，尤其在處理非同步 API 回調時，這是必須遵守的最佳實踐。

### 參考：

Invalid section

[ARC底層原理.md](./ARC底層原理.md)