# 面試官問我：「在 Swift 中處理 1 萬個元素，該用 Array 還是 Set？」

[面試官問我：「在 Swift 中處理 1 萬個元素，該用 Array 還是 Set？」— 我是這樣回答的 ! 作者：Mobile App Developer ! Stackademic ---.pdf](../Card%20Library/面試官問我：「在%20Swift%20中處理%201%20萬個元素，該用%20Array%20還是%20Set？」—%20我是這樣回答的%20!%20作者：Mobile%20App%20Developer%20!%20Stackademic%20---.pdf)

## 參考：[Array、Set、Dictionary 使用場景條列指南.md](./Array、Set、Dictionary%20使用場景條列指南.md)

- Invalid section

## 思考：

![image.png](./面試官問我：「在%20Swift%20中處理%201%20萬個元素，該用%20Array%20還是%20Set？」-assets/image.png)

### **文章分析：**

#### **1\. 文章核心論點**

本文的核心論點是，在軟體開發中，選擇 `Array` 或 `Set` 並非單純的語法問題，而是需要根據具體需求（如是否需要排序、是否允許重複）和效能考量（特別是資料量大時的查找效率）來做權衡。作者強調，面試官更看重的是開發者分析問題、權衡利弊的思考過程，而非一個單一的「正確答案」。

#### **2\. 主要內容架構**

文章透過作者親身面試的敘事結構，逐步展開論證，共分為七個步驟：

- **第一、二步：情境引入與 Array 的特性**

   - 作者以一個面試問題「處理一萬個元素，用 Array 還是 Set？」開頭，並指出不應草率回答。他首先釐清面試官的真實意圖，即測試他對資料結構的理解與權衡能力。

   - 接著，他分析了 `Array` (陣列) 的特性：保持元素順序、允許重複、透過索引進行快速存取 (時間複雜度 $O(1)$)，但檢查元素是否存在時效率較低 (時間複雜度 $O(n)$)。

- **第三步：Set 的特性**

   - 此段介紹 `Set` (集合) 的核心優勢：儲存唯一元素、不保證順序。最關鍵的是，由於其雜湊 (hashing) 機制，插入和查找操作的平均時間複雜度為 $O(1)$，效率極高。

- **第四步：效能測試**

   - 為了證明理論，作者提出透過撰寫簡單的效能測試來比較兩者在大量資料下的查找速度。測試結果明確顯示，當資料量增加時，`Set` 在查找元素方面的效能遠勝於 `Array`。

- **第五步：iOS 開發實例**

   - 作者將理論與實際應用結合，舉出在 iOS 開發中各自適合的使用情境。例如，使用 `Array` 來呈現需要固定順序的列表 (如商品清單)，而 `Set` 則適合用來確保資料的唯一性 (如檢查商品是否已加入我的最愛、移除 API 回傳的重複資料)。

- **第六、七步：最終答案與總結**

   - 作者給出了一個總結性的回答：選擇取決於具體需求。如果重視 **順序** 或 **允許重複**，應使用 `Array`。如果重視 **唯一性** 和 **查找效率**，則 `Set` 是更佳選擇。

   - 最後，作者再次強調，這個問題的重點在於展現分析與權衡的能力，並將基礎知識與實際經驗結合，這才是面試官真正想看到的。

#### **3\. 關鍵觀點整理**

參考：[Array、Set、Dictionary 使用場景條列指南.md](./Array、Set、Dictionary%20使用場景條列指南.md)

- **`Array` (陣列) 的優缺點**

   - **優點**：

      - **維持順序**：元素會按照被添加的順序排列。例如：顯示一個從 API 獲取的產品列表，順序不能改變。\[\]\[\]

      - **快速索引存取**：可透過索引值直接存取元素，時間複雜度為 $O(1)$。\[\]

      - **允許重複**：可以儲存內容相同的多個元素。\[\]

   - **缺點**：

      - **查找效率低**：檢查某個元素是否存在 (`contains`) 需要逐一比對，時間複雜度為 $O(n)$。當元素數量達到上萬甚至百萬時，會非常慢。\[\]\[\]

- **`Set` (集合) 的優缺點**

   - **優點**：

      - **確保唯一性**：自動處理重複元素，只會保留一個。例如：管理使用者的標籤或移除重複的 ID。\[\]\[\]\[\]

      - **查找效率高**：檢查某個元素是否存在 (`contains`) 的平均時間複雜度為 $O(1)$，速度非常快。\[\]\[\]

   - **缺點**：

      - **不保證順序**：元素是無序儲存的，無法依賴其排列順序。\[\]

- **選擇的關鍵在於「權衡 (Trade-offs)」**

   - 作者認為，不存在絕對的「最佳解」，只有「最適合」的解方。開發者必須根據當下情境的 **需求** (順序、唯一性) 與 **效能瓶頸** (資料量、操作頻率) 來做出決策。

#### **4\. 作者的論證邏輯**

作者採用了結構清晰、層層遞進的論證方式：

1. **提出問題**：以一個常見但刁鑽的面試問題作為引子。

2. **分析問題本質**：指出問題的核心不在答案，而在於思考過程。

3. **拆解選項**：分別詳細介紹 `Array` 和 `Set` 的資料結構特性與時間複雜度。

4. **數據佐證**：提出以效能測試來量化兩者差異的想法，增加了論點的客觀性。

5. **案例應用**：將抽象的理論與具體的 iOS 開發場景結合，使其更具說服力與實用性。

6. **總結歸納**：最後給出一個清晰、有條理的結論，並重申核心觀點。\[\]\[\]

這種從 **提出問題 -> 分析理論 -> 實驗證明 -> 實際應用 -> 總結** 的邏輯鏈，讓讀者能輕易跟隨其思路，並完整理解為何在不同情況下應做出不同選擇。

#### **5\. 可能的爭議或限制**

- **簡化了時間複雜度**：文章中提到 `Set` 的查找時間複雜度為 $O(1)$，這是「平均」情況。在極端情況下（例如雜湊碰撞嚴重），其效能可能退化到 $O(n)$。雖然在 Swift 標準庫的實作中這種情況極為罕見，但這是一個理論上的限制。

- **未討論記憶體開銷**：`Set` 為了實現高效查找，其底層結構（雜湊表）通常會比 `Array` 佔用更多的記憶體空間。在記憶體極度敏感的環境下，這也可能是一個需要考量的因素，但文章並未提及。

   - [集合型別的記憶體管理與效能最佳化.md](./集合型別的記憶體管理與效能最佳化.md)

- **情境的侷限性**：文章主要圍繞「查找」操作進行效能比較。如果主要操作是「迭代遍歷 (iteration)」，由於 `Array` 的連續記憶體佈局，其快取命中率可能更高，遍歷效能有時會略優於 `Set`。

### **值得思考的問題**

1. 除了 `Array` 和 `Set`，在 Swift 中還有哪些集合類型 (如 `Dictionary`)？它們各自適合在什麼情境下解決「處理大量元素」的問題？

   1. [Array、Set、Dictionary 使用場景條列指南.md](./Array、Set、Dictionary%20使用場景條列指南.md)

2. 文章提到 `Set` 的查找效率來自於雜湊機制。如果要將一個自訂的物件 (Custom Object) 存入 `Set`，該物件需要滿足什麼協議 (Protocol)？為什麼？

3. 在一個需要「保持唯一性」又需要「維持插入順序」的特殊情境下，你會如何用 Swift 內建的資料結構來實現？你會組合使用 `Array` 和 `Set` 嗎？如何設計？