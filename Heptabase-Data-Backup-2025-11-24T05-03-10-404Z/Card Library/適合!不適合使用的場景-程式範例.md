# 適合/不適合使用的場景-程式範例

## **一、Array（陣列）**

### **✅ 適合使用的場景**

#### 1\. **需要保持順序的資料**

```
// ✅ 聊天訊息列表（順序很重要）
struct ChatViewController {
    var messages: [Message] = []
    
    func addMessage(_ message: Message) {
        messages.append(message)  // 新訊息加在最後
    }
    
    func displayMessages() {
        // 按照時間順序顯示
        for message in messages {
            print(message.content)
        }
    }
}
​
// ✅ 播放清單（順序決定播放次序）
class MusicPlayer {
    var playlist: [Song] = []
    var currentIndex = 0
    
    func playNext() {
        currentIndex += 1
        if currentIndex < playlist.count {
            play(playlist[currentIndex])
        }
    }
}
```

#### 2\. **需要索引存取的資料**

```
// ✅ UITableView 資料源
func tableView(_ tableView: UITableView, 
               cellForRowAt indexPath: IndexPath) -> UITableViewCell {
    let item = items[indexPath.row]  // O(1) 隨機存取
    // 配置 cell
}
​
// ✅ 分頁資料
struct PaginatedData {
    var items: [Product] = []
    let pageSize = 20
    
    func getPage(_ pageNumber: Int) -> [Product] {
        let start = pageNumber * pageSize
        let end = min(start + pageSize, items.count)
        return Array(items[start..<end])  // 範圍存取很方便
    }
}
```

#### 3\. **需要排序的資料**

```
// ✅ 成績排名
struct ScoreBoard {
    var scores: [Int] = [85, 92, 78, 95, 88]
    
    func getTopScores() -> [Int] {
        return scores.sorted(by: >).prefix(3).map { $0 }
    }
}
​
// ✅ 商品列表的多種排序
class ProductList {
    var products: [Product]
    
    func sortByPrice() -> [Product] {
        return products.sorted { $0.price < $1.price }
    }
    
    func sortByRating() -> [Product] {
        return products.sorted { $0.rating > $1.rating }
    }
}
```

#### 4\. **允許重複元素**

```
// ✅ 用戶瀏覽歷史（可能重複訪問同一頁面）
class BrowsingHistory {
    var visitedPages: [URL] = []
    
    func recordVisit(_ url: URL) {
        visitedPages.append(url)  // 允許重複記錄
    }
    
    func getVisitCount(for url: URL) -> Int {
        return visitedPages.filter { $0 == url }.count
    }
}
​
// ✅ 遊戲分數記錄
var gameScores: [Int] = [100, 200, 100, 150, 200]  // 分數可能重複
```

### **❌ 不適合使用的場景**

#### 1\. **頻繁的查找操作**

```
// ❌ 錯誤：用 Array 檢查會員身份
class MembershipChecker {
    var memberIds: [String] = [...1000 個 ID...]
    
    func isMember(_ userId: String) -> Bool {
        return memberIds.contains(userId)  // O(n) 太慢！
    }
}
​
// ✅ 正確：應該用 Set
class MembershipChecker {
    var memberIds: Set<String> = [...1000 個 ID...]
    
    func isMember(_ userId: String) -> Bool {
        return memberIds.contains(userId)  // O(1) 快速查找
    }
}
```

#### 2\. **需要保證唯一性**

```
// ❌ 錯誤：用 Array 儲存標籤（可能重複）
class Article {
    var tags: [String] = []
    
    func addTag(_ tag: String) {
        if !tags.contains(tag) {  // 每次都要檢查，O(n)
            tags.append(tag)
        }
    }
}
​
// ✅ 正確：應該用 Set
class Article {
    var tags: Set<String> = []
    
    func addTag(_ tag: String) {
        tags.insert(tag)  // 自動去重，O(1)
    }
}
```

#### 3\. **頻繁的中間插入/刪除**

```
// ❌ 錯誤：優先佇列用 Array 實作
class PriorityQueue {
    var items: [Task] = []
    
    func insert(_ task: Task) {
        // 找到正確位置插入，O(n)
        let index = items.firstIndex { $0.priority < task.priority } ?? items.count
        items.insert(task, at: index)  // 插入會移動後面所有元素，又是 O(n)
    }
}
​
// ✅ 正確：應該用 Heap 資料結構（或考慮其他方案）
```

---

## **二、Set（集合）**

### ✅ 適合使用的場景

#### 1\. **需要快速查找成員資格**

```swift
// ✅ 黑名單系統
class ContentFilter {
    let blockedUserIds: Set<String> = ["user123", "user456", ...]
    
    func isBlocked(_ userId: String) -> Bool {
        return blockedUserIds.contains(userId)  // O(1)
    }
}

// ✅ 權限檢查
struct User {
    let permissions: Set<String> = ["read", "write", "delete"]
    
    func hasPermission(_ permission: String) -> Bool {
        return permissions.contains(permission)  // O(1)
    }
}
```

#### 2\. **需要去重**

```swift
// ✅ 文章中的唯一標籤
class BlogPost {
    var tags: Set<String> = []
    
    func addTags(_ newTags: [String]) {
        tags.formUnion(newTags)  // 自動去重
    }
}

// ✅ 用戶的唯一技能
struct UserProfile {
    var skills: Set<String> = []
    
    func addSkill(_ skill: String) {
        skills.insert(skill)  // 不用擔心重複
    }
}
```

#### 3\. **集合運算（交集、聯集、差集）**

```swift
// ✅ 共同好友功能
class SocialNetwork {
    func findMutualFriends(user1: User, user2: User) -> Set<String> {
        return user1.friendIds.intersection(user2.friendIds)  // 交集
    }
    
    func suggestFriends(for user: User) -> Set<String> {
        var suggestions = Set<String>()
        for friendId in user.friendIds {
            if let friend = getUser(friendId) {
                // 朋友的朋友減去已經是朋友的
                suggestions.formUnion(friend.friendIds.subtracting(user.friendIds))
            }
        }
        suggestions.remove(user.id)  // 移除自己
        return suggestions
    }
}

// ✅ 購物車中的重複檢查
class ShoppingCart {
    var productIds: Set<String> = []
    
    func merge(with other: ShoppingCart) {
        productIds.formUnion(other.productIds)  // 合併購物車
    }
    
    func hasConflict(with wishlist: Set<String>) -> Bool {
        return !productIds.intersection(wishlist).isEmpty
    }
}
```

#### 4\. **不在乎順序的唯一元素集合**

```swift
// ✅ 已讀訊息 ID
class MessageTracker {
    var readMessageIds: Set<String> = []
    
    func markAsRead(_ messageId: String) {
        readMessageIds.insert(messageId)
    }
    
    func isRead(_ messageId: String) -> Bool {
        return readMessageIds.contains(messageId)
    }
}

// ✅ 下載佇列中的唯一檔案
class DownloadManager {
    var pendingDownloads: Set<URL> = []
    
    func addToQueue(_ url: URL) {
        pendingDownloads.insert(url)  // 避免重複下載
    }
}
```

### ❌ 不適合使用的場景

#### 1\. **需要保持順序**

```swift
// ❌ 錯誤：歷史記錄用 Set
class BrowserHistory {
    var visitedURLs: Set<URL> = []  // 失去了時間順序！
    
    func addVisit(_ url: URL) {
        visitedURLs.insert(url)
    }
    
    func getHistory() -> [URL] {
        return Array(visitedURLs)  // 順序是任意的，不對！
    }
}

// ✅ 正確：應該用 Array
class BrowserHistory {
    var visitedURLs: [URL] = []
    
    func addVisit(_ url: URL) {
        visitedURLs.append(url)
    }
}
```

#### 2\. **需要索引存取**

```swift
// ❌ 錯誤：Set 沒有下標存取
let names: Set<String> = ["Alice", "Bob", "Charlie"]
// names[0]  // 編譯錯誤！Set 沒有順序

// 如果真的需要取第一個
if let first = names.first {  // 但這是任意的一個，不是"第一個"
    print(first)
}
```

#### 3\. **需要計數或允許重複**

```swift
// ❌ 錯誤：統計單字出現次數用 Set
var words: Set<String> = []
// 無法記錄 "apple" 出現了 3 次

// ✅ 正確：應該用 Dictionary
var wordCount: [String: Int] = [:]
wordCount["apple", default: 0] += 1
```

#### 4\. **元素不符合 Hashable**

```swift
// ❌ 錯誤：無法把不 Hashable 的型別放入 Set
struct Point {
    var x: Double
    var y: Double
}

// var points: Set<Point> = []  // 編譯錯誤！

// ✅ 需要讓 Point 遵循 Hashable
struct Point: Hashable {
    var x: Double
    var y: Double
}

var points: Set<Point> = []  // 現在可以了
```

---

## 三、Dictionary（字典）

### ✅ 適合使用的場景

#### 1\. **鍵值對應關係**

```swift
// ✅ 用戶快取
class UserCache {
    var users: [String: User] = [:]  // userId -> User
    
    func getUser(_ id: String) -> User? {
        return users[id]  // O(1) 查找
    }
    
    func cacheUser(_ user: User) {
        users[user.id] = user
    }
}

// ✅ 設定管理
class AppSettings {
    var settings: [String: Any] = [
        "theme": "dark",
        "fontSize": 14,
        "notifications": true
    ]
    
    func getSetting<T>(_ key: String) -> T? {
        return settings[key] as? T
    }
}
```

#### 2\. **計數或分組**

```swift
// ✅ 統計單字頻率
func countWords(_ text: String) -> [String: Int] {
    var wordCount: [String: Int] = [:]
    let words = text.components(separatedBy: .whitespaces)
    
    for word in words {
        wordCount[word, default: 0] += 1
    }
    
    return wordCount
}

// ✅ 按類別分組產品
func groupProducts(_ products: [Product]) -> [String: [Product]] {
    var grouped: [String: [Product]] = [:]
    
    for product in products {
        grouped[product.category, default: []].append(product)
    }
    
    return grouped
}
```

#### 3\. **建立索引加速查找**

```swift
// ✅ 通訊錄快速查找
class ContactBook {
    var contacts: [Contact] = []
    var contactIndex: [String: Contact] = [:]  // 用 ID 建立索引
    
    func buildIndex() {
        contactIndex = Dictionary(uniqueKeysWithValues: 
            contacts.map { ($0.id, $0) }
        )
    }
    
    func findContact(byId id: String) -> Contact? {
        return contactIndex[id]  // O(1) 而不是 O(n)
    }
}

// ✅ 多欄位索引
class ProductDatabase {
    var products: [Product] = []
    var byId: [String: Product] = [:]
    var bySKU: [String: Product] = [:]
    
    func buildIndices() {
        byId = Dictionary(uniqueKeysWithValues: products.map { ($0.id, $0) })
        bySKU = Dictionary(uniqueKeysWithValues: products.map { ($0.sku, $0) })
    }
}
```

#### 4\. **配置和映射**

```swift
// ✅ HTTP 狀態碼映射
let httpStatusMessages: [Int: String] = [
    200: "OK",
    404: "Not Found",
    500: "Internal Server Error"
]

// ✅ 鍵盤快捷鍵映射
enum Action {
    case save, copy, paste, undo
}

let keyBindings: [String: Action] = [
    "⌘S": .save,
    "⌘C": .copy,
    "⌘V": .paste,
    "⌘Z": .undo
]

// ✅ API 端點映射
let endpoints: [String: String] = [
    "users": "/api/v1/users",
    "products": "/api/v1/products",
    "orders": "/api/v1/orders"
]
```

#### 5\. **快取和備忘錄模式**

```swift
// ✅ 圖片快取
class ImageCache {
    var cache: [URL: UIImage] = [:]
    
    func getImage(from url: URL) async -> UIImage? {
        // 先檢查快取
        if let cached = cache[url] {
            return cached
        }
        
        // 下載並快取
        if let image = try? await downloadImage(from: url) {
            cache[url] = image
            return image
        }
        
        return nil
    }
}

// ✅ 計算結果快取（Memoization）
class Calculator {
    var fibCache: [Int: Int] = [:]
    
    func fibonacci(_ n: Int) -> Int {
        if n <= 1 { return n }
        
        if let cached = fibCache[n] {
            return cached
        }
        
        let result = fibonacci(n-1) + fibonacci(n-2)
        fibCache[n] = result
        return result
    }
}
```

### ❌ 不適合使用的場景

#### 1\. **需要保持插入順序**

```swift
// ❌ 錯誤：Dictionary 不保證順序
var settings: [String: String] = [:]
settings["firstName"] = "John"
settings["lastName"] = "Doe"
settings["email"] = "john@example.com"

for (key, value) in settings {
    print("\(key): \(value)")
}
// 輸出順序是不確定的！

// ✅ 正確：如果需要順序，用 Array of tuples
var settings: [(String, String)] = [
    ("firstName", "John"),
    ("lastName", "Doe"),
    ("email", "john@example.com")
]
```

#### 2\. **只需要 Set 的場景**

```swift
// ❌ 錯誤：只需要檢查存在性，卻用 Dictionary
var visitedPages: [URL: Bool] = [:]
visitedPages[someURL] = true

if visitedPages[someURL] == true {
    // ...
}

// ✅ 正確：應該用 Set
var visitedPages: Set<URL> = []
visitedPages.insert(someURL)

if visitedPages.contains(someURL) {
    // ... 更清晰
}
```

#### 3\. **鍵不符合 Hashable**

```swift
// ❌ 錯誤：自訂型別沒有遵循 Hashable
struct Location {
    var latitude: Double
    var longitude: Double
}

// var locationNames: [Location: String] = [:]  // 編譯錯誤

// ✅ 正確：讓 Location 遵循 Hashable
struct Location: Hashable {
    var latitude: Double
    var longitude: Double
}

var locationNames: [Location: String] = [:]
```

#### 4\. **需要按順序遍歷**

```swift
// ❌ 錯誤：想要按名字排序顯示用戶
var users: [String: User] = [
    "user3": User(name: "Charlie"),
    "user1": User(name: "Alice"),
    "user2": User(name: "Bob")
]

// Dictionary 的順序是任意的
for (id, user) in users {
    print(user.name)  // 順序不可預測
}

// ✅ 正確：轉成 Array 再排序
let sortedUsers = users.values.sorted { $0.name < $1.name }
```

---

## 四、實戰決策流程圖

```
開始選擇集合型別
    ↓
需要 Key-Value 對應？
    ├─ 是 → Dictionary
    └─ 否 ↓
    
需要保證唯一性且不在乎順序？
    ├─ 是 → Set
    └─ 否 ↓
    
需要頻繁查找成員資格？
    ├─ 是 → Set（然後轉 Array 如果需要順序）
    └─ 否 ↓
    
需要保持順序或索引存取？
    ├─ 是 → Array
    └─ 否 → 重新思考需求
```

## 五、組合使用的實際案例

```swift
// 實戰：一個完整的購物車系統
class ShoppingCart {
    // 用 Dictionary 快速查找商品和數量
    private var items: [String: CartItem] = [:]  // productId -> CartItem
    
    // 用 Array 維持加入順序（用於顯示）
    private var itemOrder: [String] = []  // productId 的順序
    
    // 用 Set 記錄已應用的優惠碼（去重）
    private var appliedCoupons: Set<String> = []
    
    struct CartItem {
        let product: Product
        var quantity: Int
    }
    
    func addProduct(_ product: Product, quantity: Int = 1) {
        if items[product.id] != nil {
            // 已存在，增加數量
            items[product.id]!.quantity += quantity
        } else {
            // 新商品
            items[product.id] = CartItem(product: product, quantity: quantity)
            itemOrder.append(product.id)  // 記錄順序
        }
    }
    
    func applyCoupon(_ code: String) -> Bool {
        guard !appliedCoupons.contains(code) else {
            return false  // 已使用過
        }
        
        // 驗證優惠碼...
        appliedCoupons.insert(code)
        return true
    }
    
    func getOrderedItems() -> [CartItem] {
        // 按照加入順序返回
        return itemOrder.compactMap { items[$0] }
    }
    
    func getTotalPrice() -> Double {
        return items.values.reduce(0) { total, item in
            total + (item.product.price * Double(item.quantity))
        }
    }
}
```

**總結**：選擇正確的集合型別不是背誦規則，而是理解每種型別的**時間複雜度**、**特性限制**和**使用場景**。在實際開發中，經常會組合使用多種集合型別來達到最佳效果。