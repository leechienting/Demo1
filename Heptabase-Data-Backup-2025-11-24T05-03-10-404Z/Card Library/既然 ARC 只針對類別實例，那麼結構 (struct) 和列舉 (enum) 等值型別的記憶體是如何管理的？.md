# 既然 ARC 只針對類別實例，那麼結構 (struct) 和列舉 (enum) 等值型別的記憶體是如何管理的？

ARC (Automatic Reference Counting) 確實主要針對「類別實例」進行記憶體管理，因為類別是引用型別。而結構 (struct) 和列舉 (enum) 這些「值型別」的記憶體管理方式則不同，它們通常不依賴 ARC 來釋放記憶體。

以下是結構 (struct) 和列舉 (enum) 記憶體管理的運作方式：

1. **堆疊分配 (Stack Allocation)**

   - **作用域管理**：對於大多數值型別，當它們在函數內部或程式碼區塊中被建立時，記憶體通常會分配在「堆疊 (Stack)」上。堆疊是一種「後進先出 (LIFO)」的資料結構，記憶體的分配和釋放都非常快速且自動。

   - **自動釋放**：當值型別超出其作用域 (例如，函數執行完畢或程式碼區塊結束時)，它所佔用的堆疊記憶體會被自動、立即地回收，不需要引用計數器來追蹤。這也是為什麼它們不需要 ARC 的原因。

   - **複製行為**：值型別在被賦值給新變數或作為函數參數傳遞時，會進行「複製 (copy)」而不是傳遞引用。這意味著每個變數都擁有自己獨立的資料副本，修改其中一個不會影響另一個。這種複製行為對於完全分配在堆疊上的值型別來說，通常是非常高效的。

2. **堆積分配 (Heap Allocation) 的情況** 雖然值型別通常分配在堆疊上，但在某些情況下，它們也可能涉及到「堆積 (Heap)」分配：

   - **包含引用型別**：如果一個結構或列舉內部包含了一個或多個引用型別 (例如，類別實例、閉包或 `String`、`Array`、`Dictionary`、`Set` 等 Swift 標準庫中的複雜值型別，這些型別內部其實包含了引用型別來管理其資料儲存)，那麼這些內部的引用型別會被分配在堆積上，並由 ARC 來管理其生命週期。當外部的值型別被銷毀時，它會釋放對內部引用型別的強引用，然後由 ARC 根據引用計數來決定何時釋放堆積上的記憶體。

   - **大小過大**：在某些情況下，如果一個值型別的大小超過了編譯器預設的閾值 (例如，在 64 位元機器上大於 24 位元組)，Swift 編譯器可能會選擇將它分配在堆積上。然而，即使它們分配在堆積上，它們仍然保持值語義，並由 Swift 負責其分配和釋放，ARC 仍不會直接管理它們。

   - **間接列舉 (Indirect Enums)**：對於包含遞歸關聯值的列舉 (使用 `indirect` 關鍵字)，它們會被分配在堆積上，以便支援遞歸資料結構，並且這部分的記憶體會由 ARC 管理。

總結來說，ARC 只管理引用型別 (如類別) 的記憶體。值型別 (如結構和列舉) 的記憶體管理主要依賴於它們的作用域，通常透過堆疊分配來實現自動釋放。然而，如果值型別內部包含了引用型別，或者在某些特殊情況下 (例如間接列舉或非常大的結構)，記憶體也可能涉及堆積分配，這時內部引用型別的生命週期才會由 ARC 管理。